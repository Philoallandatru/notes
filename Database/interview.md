

## 触发器




## 存储过程

#### 2、什么是存储过程？用什么来调用？

存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。 调用： 1）可以用一个命令对象来调用存储过程。 2）可以供外部程序调用，比如：java程序。

#### 3、存储过程的优缺点？

优点： 1）存储过程是预编译过的，执行效率高。 2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。 3）安全性高，执行存储过程需要有一定权限的用户。 4）存储过程可以重复使用，可减少数据库开发人员的工作量。 缺点：移植性差

#### 4、存储过程与函数的区别

| 存储过程                                               | 函数                                                         |
| ------------------------------------------------------ | ------------------------------------------------------------ |
| 用于在数据库中完成特定的操作或者任务（如插入、删除等） | 用于特定的数据（如选择）                                     |
| 程序头部声明用procedure                                | 程序头部声明用function                                       |
| 程序头部声明时不需描述返回类型                         | 程序头部声明时要描述返回类型，而且PL/SQL块中至少要包括一个有效的return语句 |
| 可以使用in/out/in out 三种模式的参数                   | 可以使用in/out/in out 三种模式的参数                         |
| 可作为一个独立的PL/SQL语句来执行                       | 不能独立执行，必须作为表达式的一部分调用                     |
| 可以通过out/in out 返回零个或多个值                    | 通过return语句返回一个值，且改值要与声明部分一致，也可以是通过out类型的参数带出的变量 |
| SQL语句(DML 或SELECT)中不可调用存储过程                | SQL语句(DML 或SELECT)中可以调用函数                          |

## 

## 索引

#### 5、索引的作用？和它的优点缺点是什么？

索引就一种特殊的查询表，数据库的搜索可以利用它加速对数据的检索。它很类似与现实生活中书的目录，不需要查询整本书内容就可以找到想要的数据。索引可以是唯一的，创建索引允许指定单个列或者是多个列。缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小。

#### 6、什么样的字段适合建索引

唯一、不为空、经常被查询的字段

#### 7、索引类型有哪些？

逻辑上：
Single column 单行索引
Concatenated 多行索引
Unique 唯一索引
NonUnique 非唯一索引
Function-based 函数索引
Domain 域索引 物理上：
Partitioned 分区索引
NonPartitioned 非分区索引
B-tree ：
Normal 正常型B树
Rever Key 反转型B树 Bitmap 位图索引



## 事务与锁

#### Q 什么是事务？什么是锁？

事务就是被绑定在一起作为一个逻辑工作单元的SQL语句分组，如果任何一个语句操作失败那么整个操作就被失败，以后操作就会回滚到操作前状态，或者是上有个节点。为了确保要么执行，要么不执行，就可以使用事务。要将有组语句作为事务考虑，就需要通过ACID测试，即原子性，一致性，隔离性和持久性。 锁：在所以的DBMS中，锁是实现事务的关键，锁可以保证事务的完整性和并发性。与现实生活中锁一样，它可以使某些数据的拥有者，在某段时间内不能使用某些数据或数据结构。当然锁还分级别的。

#### Q 封锁？封锁类型？

封锁就是事务T在对某个数据对象操作之前，先向系统发出加锁请求，加锁后事务T就对该数据对象有了一定的控制权，在事务T释放它的锁之前，其它事务不能更新该数据对象。
共享锁和排它锁是两种基本锁类型。
共享锁又称读锁。如果事务T获得了数据对象Q上的共享锁，则T可以读但不能写Q，并且在T释放Q上的S锁之前，其它事务只能获得Q上的S锁，而不能获得Q上的X锁。
排他锁又称写锁。如果事务T获得了数据项Q上的排它锁，则T既可以读又可以写Q，但是在T释放Q上的X锁之前，其它事务既不能获得Q上的S锁，也不能获得Q上的X锁。

#### Q 活锁？

锁又称饥饿，是某个事务因等待锁而处于无限期等待状态。
活锁是不公平的锁调度导致的。可以采用先来先服务的策略来避免某个事务无限期期等待。即当多个事务请求封锁同一数据对象时，封锁子系统按请求封锁的先后次序对事务排队。数据对象上的锁一旦释放，就将锁授予申请队列中的第一个事务。

#### Q 死锁？

死锁是两个或两个以上的事务之间的循环等待现象。死锁发生时，两个或多个事务都处于等待状态，每个事务都等待其它事务释放锁，以便可以继续执行。
预防死锁的基本方法是破坏死锁产生的条件，可以采用一次封锁、顺序封锁方法。

#### Q 死锁如何检测和预防

检测：超时法，设置时间，超过则死锁；
等待图法，如果图中有回路，这就是死锁。
预防：一次封锁法，事务一次性对要使用的属于对象加锁，不加锁就不能运行；
顺序封锁法，预先对数据对象规定一个封锁顺序，所有的事务都按照这个封锁顺序来。

#### Q 什么是事务的可串行化

多个事务并发执行时，当且尽当结果与某一次顺序串行执行的结果相同，称这种调度为可串行化调度。可串行化调度是并行调度正确的唯一准则。

#### Q 什么是锁？有哪两种锁？

锁是最常用的并发控制机构，是防止其他事务访问指定资源，实现并发控制的一种手段。

- 排他锁（X写锁）：当数据被加上写锁，其他事务不能对该数据进行读和写；
- 共享锁（S读锁）：当数据被加上读锁，允许其他事务对该数据进行读，不允许写。

#### Q 简要概括一、二、三级封锁协议

- 一级封锁协议：事务在修改数据之前加写锁，直到事务结束才释放。该协议可以防止丢失修改；
- 二级封锁协议：在一级封锁协议的基础上，加上了事务在读取数据之前对其加读锁，读完后即可释放读锁。该协议避免了读脏数据；
- 三级封锁协议：在一级封锁协议的基础上，加上了事务在读取数据之前必须加上读锁，直到事务结束才释放。该协议解决了不可重复读问题。

#### Q 描述两段锁协议

协议规定（1）对任何数据读写之前，必须要获得该数据的封锁；（2）释放了一个锁之后，事务不能再获取其它的封锁。第一阶段只获得锁，第二阶段只释放锁。
两段锁协议可以保证事务的可串行化，是充分条件。



## 数据库恢复技术

#### 1.故障的种类

1.事务内部的故障：
2.系统故障：如操作系统故障，CPU故障，系统断电
3.介质故障：如磁盘损坏、磁头碰撞、瞬时强磁场干扰等
4.计算机病毒

#### 2.恢复策略

REDO：重做，正向扫描日志文件，对每个REDO事务重新执行日志文件登记的操作
UDNO：撤销，反向扫描日志文件，对每个UNDO事务的更新操作执行逆操作
COMMIT：提交，将事务中所有对数据库的更新写回到磁盘上的物理数据库中，事务正常结束
ROLLBACK：回滚，事务运行的过程中发生了某种故障，事务不能继续执行，系统将事务中对数据库的所有已完成操作全部撤销，回滚到事务开始时的状态

#### 3.故障的种类和恢复方法

1，事务故障及其恢复：事务故障表示由非预期的、不正常的程序结束所造成的故障。造成程序非正常结束的原因包括输人数据错误、运算溢出、违反存储保护、并行事务发生死锁等。发生事务故障时，被迫中断的事务可能已对数据库进行丁修改，为了消除该事务对数据库的影响，要利用日志文件中所记载的信息，强行回滚该事务，进行undo操作，将数据库恢复到修改前的初始状态。
2、系统故障：系统故障是指系统在运行过程中，由于某种原因，造成系统停止运转，致使所有正在运行的事务都以非正常方式终止，要求系统重新启动。引起系统故障的原因可能有硬件错误（如CPu故障、操作系统）或DBMS代码错误、突然断电等。
系统故障发生后，对数据库的影响有以下两种情况
（1）一些未完成事务对数据库的更新已写入数据库，这样在系统重新启动后，要undo所有未完成的事务末完成事务。（2）有些事务处于部分提交状态，进行redo操作。
3、介质故障：介质故障是指系统在运行过程中，由于辅助存储器介质受到破坏，使存储在外存中的数据部分或全部丢失。恢复时需要装入数据库副本

#### 4.述数据转储技术

根据转储时系统状态
1、静态转储；停止数据库中所有事务进行转储操作。
2、动态转储：可以运行事务并转储，但要在转储期间要记录数据活动的日志。恢复时通过日志和副本共同恢复。
根据转储量
1、海量转储，一次性转储全部数据。
2、增量转储，只转储更新过的数据，适用于更新频繁的系统。

#### 5.使用日志的数据库恢复技术

推迟更新技术和即时更新技术
推迟更新技术协议：每个数据到达提交点之前不能更新数据库；一个事务的所有更新操作对应的日志记录写入永恒存储器之前，该事务不能到达提交点。
即时更新技术协议：所有“更新类型”的日志记录安全地存储到永恒存储器之前，事务T不能更新数据库，且不允许事务T提交。



## 视图

#### 9、什么叫视图？游标是什么？

视图：是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。 游标：是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。

#### 10、视图的优缺点

优点： 1）对数据库的访问，因为视图可以有选择性的选取数据库里的一部分。 2 ）用户通过简单的查询可以从复杂查询中得到结果。 3 ）维护数据的独立性，试图可从多个表检索数据。 4 ）对于相同的数据可产生不同的视图。 缺点： 性能：查询视图时，必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，那么就无法更改数据



## SQL

#### 11、列举几种表连接方式,有什么区别？

内连接、自连接、外连接（左、右、全）、交叉连接 内连接：只有两个元素表相匹配的才能在结果集中显示。 外连接： 左外连接:左边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。 右外连接:右边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。 全外连接：连接的表中不匹配的数据全部会显示出来。 交叉连接： 笛卡尔效应，显示的结果是链接表数的乘积。

#### 12、主键和外键的区别？

主键在本表中是唯一的、不可唯空的，外键可以重复可以唯空；外键和另一张表的主键关联，不能创建对应表中不存在的外键。

#### 13、在数据库中查询语句速度很慢，如何优化？

1.建索引 2.减少表之间的关联 3.优化sql，尽量让sql很快定位数据，不要让sql做全表查询，应该走索引,把数据 量大的表排在前面 4.简化查询字段，没用的字段不要，已经对返回结果的控制，尽量返回少量数据 5.尽量用PreparedStatement来查询，不要用Statement



#### 15、union和union all有什么不同?

UNION在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。实际大部分应用中是不会产生重复的记录，最常见的是过程表与历史表UNION。 UNION ALL只是简单的将两个结果合并后就返回。这样，如果返回的两个结果集中有重复的数据，那么返回的结果集就会包含重复的数据了。 从效率上说，UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复的数据的话，那么就使用UNION ALL。

#### 16、Varchar2和varchar有什么区别？

Char的长度是固定的，而varchar2的长度是可以变化的，比如，存储字符串“abc”对于char(20)，表示你存储的字符将占20个字节，包含17个空，而同样的varchar2（20）只占了3个字节，20只是最大值，当你存储的字符小于20时，按实际长度存储。 char的效率要被varchar2的效率高。 目前varchar是varchar2的同义词，工业标准的varchar类型可以存储空字符串，但是oracle不能这样做，尽管它保留以后这样做的权利。[Oracle](https://m.2cto.com/database/Oracle/)自己开发了一个数据类型varchar2,这个类型不是一个标准的varchar，他将在数据库中varchar列可以存储空字符串的特性改为存储null值，如果你想有向后兼容的能力，oracle建议使用varchar2而不是varchar

## 范式

#### Q 数据库三范式是什么?

第一范式：列不可再分 

第二范式：行可以唯一区分，主键约束 

第三范式：表的非主属性不能依赖与其他表的非主属性 外键约束 且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立第一第二范式上

#### Q 为什么范式会出现？

在数据库设计中，不合理的设计会导致数据冗余、更新异常、插入异常、删除异常。这些都是由于不合理的数据依赖导致的，范式理论的出现为了解决不合理的数据依赖，是数据库设计规范化。

#### Q 解释1到4范式和BC范式？

1NF:数据库中的每一列都是不可分割的简单属性。不满足这一条的数据库就不能称为关系型数据库。
2NF：在1NF的基础上，非码属性必须完全依赖于候选码
3NF：在2NF基础上，任何非主属性不依赖于其它非主属性。
BCNF:在1NF的基础上，所有的函数依赖，例如X->Y，决定因素X中都包含了R的一个候选码
4NF：关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。

规范化的过程中：
1NF到2NF消除了非主属性对码的部分函数依赖；
2NF到3NF消除了非主属性对码的传递函数依赖；
3NF到BCNF消除了主属性对码的部分函数依赖和传递函数依赖；
BCNF到4NF消除了非平凡且非函数依赖的多值依赖。







## 数据库

#### 17、Oracle和Mysql的区别？

   1）库函数不同。 2）Oracle是用表空间来管理的，Mysql不是。 3）显示当前所有的表、用户、改变连接用户、显示当前连 接用户、执行外部脚本的语句的不同。 4）分页查询时候时候，[mysql](https://m.2cto.com/database/MySQL/)用limit oracle用rownum

1. mysql> **SELECT** * **FROM table** LIMIT 5,10; // 检索记录行 6-15 //为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：
2. mysql> **SELECT** * **FROM table** LIMIT 95,-1; // 检索记录行 96-**last**. //如果只给定一个参数，它表示返回最大的记录行数目：
3. mysql> **SELECT** * **FROM table** LIMIT 5; //检索前 5 个记录行 //换句话说，LIMIT n 等价于 LIMIT 0,n。
4. sql的语法的不同。

#### 18、Oracle语句有多少类型

Oracle语句分三类：DDL、DML、DCL。 DDL（Data Definition Language）数据定义语言，包括： Create语句：可以创建数据库和数据库的一些对象。 Drop语句：可以删除数据表、索引、触发程序、条件约束以及数据表的权限等。 Alter语句：修改数据表定义及属性。 Truncate语句：删除表中的所有记录,包括所有空间分配的记录被删除。 DML（Data Manipulation Language）数据操控语言，包括： Insert语句：向数据表张插入一条记录。 Delete语句：删除数据表中的一条或多条记录，也可以删除数据表中的所有记录，但是它的操作对象仍是记录。 Update语句：用于修改已存在表中的记录的内容。 DCL（Data Control Language）数据库控制语言，包括： Grant语句：允许对象的创建者给某用户或某组或所有用户（PUBLIC）某些特定的权限。 Revoke语句：可以废除某用户或某组或所有用户访问权限

#### 19、oracle分页查询语句

使用rownum，两种如下： 第一种： select * from (select t.*,rownum row_num from mytable t) b where b.row_num between 1 and 10 第二种： select * from ( select a.*, rownum rn from mytable a where rownum <= 10 ) where rn >= 1 使用rowid， 如下： select * from scott.emp where rowid in (select rd from (select rowid as rd ,rownum as rn from scott.emp ) where rn<=6 and rn>3)

#### 20、从数据库中随机取50条

select * from (select * from t_example order by dbms_random.random) where rownum <= 50

#### 21、order by与group by的区别

order by 排序查询、asc升序、desc降序 group by 分组查询、having 只能用于group by子句、作用于组内，having条件子句可以直接跟函数表达式。使用group by 子句的查询语句需要使用聚合函数。

#### 22、commit在哪里会运用

oracle的commit就是DML语句提交数据（这里是释放锁不是锁表），在未提交前你前面的操作更新的都是内存，没有更新到物理文件中。 执行commit从用户角度讲就是更新到物理文件了，事实上commit时还没有写date file，而是记录了redo log file，要从内存写到data物理文件，需要触发检查点，由DBWR这个后台进程来写，这里内容有点多的，如果不深究的话你就理解成commit即为从内存更新到物理文件。

#### 23、行转列、列换行怎么转

1）使用decode函数 2）使用case when语句

#### 24、什么是PL/SQL？

PL/SQL是一种程序语言，叫做过程化SQL语言（Procedural Language/SQL）。PL/SQL是Oracle数据库对[SQL语句](https://so.csdn.net/so/search?q=SQL语句&spm=1001.2101.3001.7020)的扩展。在普通SQL语句的使用上增加了[编程](https://m.2cto.com/kf)语言的特点，所以PL/SQL把数据操作和查询语句组织在PL/SQL代码的过程性单元中，通过逻辑判断、循环等操作实现复杂的功能或者计算。PL/SQL 只有 Oracle 数据库有。 MySQL 目前不支持 PL/SQL 的。

#### 25、序列的作用

Oracle使用序列来生成唯一编号，用来处理一个表中自增字段。 Oracle序列是原子对象，并且是一致的。也就是说，一旦您访问一个序列号，Oracle将在处理下一个请求之前自动递增下一个编号，从而确保不会出现重复值。

#### 26、表和视图的关系

视图其实就是一条查询sql语句，用于显示一个或多个表或其他视图中的相关数据。 表就是关系数据库中实际存储数据用的。

#### 27、oracle基本数据类型

1）字符串类型 char、nchar、varchar、varchar2、nvarchar2 2）数字类型 number、integer 3）浮点类型 binary_float、binary_double、float 4）日期类型 date、 timestamp 5）LOB类型 blob、clob、nclob、bfile

#### 28、truncate与 delete区别

TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的[系统](https://m.2cto.com/os/)和事务日志资源少。 DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。
TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。 TRUNCATE,DELETE,DROP 放在一起比较：
TRUNCATE TABLE ：删除内容、释放空间但不删除定义。
DELETE TABLE: 删除内容不删除定义，不释放空间。
DROP TABLE ：删除内容和定义，释放空间。

#### 29、oracle获取系统时间

select to_char(sysdate, 'yyyy-MM-dd HH24:mi:ss') from dual;

#### 30、oracle怎么去除去重

使用distinct关键字

#### 31、现在有表:

A(id ,name,regdate) B(id,groupid) C(id,name2) 写出下面的SQL语句 A)统计A表中每个月注册用户数 select count(*),to_char(regdate,'yyyymm') from A group by to_char(regdate,'yyyymm'); B)统计A表中有姓名相同的用户数 select count(*) from (select name from A group by name having count(*) >1); C)如果表A中有姓名相同的用户,把相同的查出,写入表C中 nsert into C(name2) select name from A group by name having count(*) >1; D)A中ID有多个相同的数据,A中姓名相同的ID只保留注册时间最大的数据 delete from E where e.regdate < (select max(regdate) from a X where E.id = X.id);

#### 32、现有表：

Student(S#,SN,SD)学生表 Course(C#,CN,T#)课程表 SC（S#,C#,score）成绩表 1.查询选了课程‘税收’的学生的学号和名字 答： select SN,SD from Student where S# in( select S# from Course C , SC where C.C#=SC.C# and CN= ’税收基础’); 2.查询选课数量大于5的学生的学号和名字 答： select SN,SD from Student where S# in ( select S# from SC group by S# having count(distinct C#) > 5); ) 3.建立一个学生表students，包括name,age,head_teacher,id,score(姓名，年龄，班主任，学号，成绩) Create table students ( Id number(9) not null primary key, Name varchar2(40) not null, Age int check(age between 0 and 100), Head_teacher vachar2(40), Score float ); 4.对上表插入一条记录，姓名：张三，年龄：18，班主任：李四，学号：22 Insert into student(id,name,age,head_teacher) values(‘22’,’张三’,’18’,’李四’)； 5.对上表中的age+name创建一个索引，并说明它的作用和使用方法 Create index student_index on students(age,name);

#### 33、怎样把这样一个表（表名：tmp_table_201307）

year month amount 2012 1 1.1 2012 2 1.2 2012 3 1.3 2012 4 1.4 2012 4 1.6 2013 1 2.1 2013 2 2.2 2013 2 2.2 2013 3 2.3 　2013 4 2.4 　　查成这样一个结果 　　year m1 m2 m3 m4 　　2012 1.1 1.2 1.3 3 　　2013 2.1 4.4 2.3 2.4 　　Select 　　year, 　　Sum(case when month = 1 then amount else 0 end) as m1, 　　Sum(case when month = 2 then amount else 0 end) as m2, 　　Sum(case when month = 3 then amount else 0 end) as m3, 　　Sum(case when month = 4 then amount else 0 end) as m4 　　From tmp_table_201307 a 　　Group by year 　　Order by 1;

#### 34、数据库中有一张表ismg_icp_flow，结构如下

SQL> desc ismg_icp_flow Name Null Type ———————————————————————————————— ICPNO NOT NULL VARCHAR2(6) SERVICE_ID NOT NULL VARCHAR2(10) STAT_MIN NOT NULL DATETIME MT_RECV_OK NOT NULL NUMBER(10) 请写出一条SQL语句同时满足以下3个条件： 计算MT_RECV_OK的总和（显示为total），并以此对结果集进行升序排序 以ICPNO和SERVICE_ID两个字段进行分组 所得出数据的STAT_MIN必须为大于2003年1月1号0时0分并且小于2003 年2月1号0时0分 期望的输出结果如下： ICPNO SERVICE_ID TOTAL ———— —————— ———————————— 901001 7700 271965 901001 7800 3857795 答： select ICPNO,SERVICE_ID,sum(MT_RECV_OK) TOTAL from ismg_icp_flow where STAT_MIN between to_date('2003-1-1','yyyy-mm-dd') and to_date('2003-2-1','yyyy-mm-dd') group by ICPNO,SERVICE_ID order by TOTAL;

## 并发

#### Q 在数据库中为什么要并发控制？

数据库是共享资源，通常有多个事物在同时执行，当多个事物并发的存取数据库时就会存在同时读或写统一数据的情况，如果对并发操作不加控制，就会存在数据读取或存取错误，破坏数据库的一致性。

#### Q 并发造成的数据不一致性包括什么？

- 丢失修改：A、B两个事物同时对一个数据进行操作，A的修改破坏了B的修改，导致B的修改丢失；

- 不可重复读：A读取了数据后，B对数据进行了修改，导致A无法再现前一次的读取结果；

- 读脏数据：A对数据进行了修改之后，B读入该数据，然后A又因为某一原因撤销了该修改，导致数据恢复原值，此时B读取的数据就成了脏数据。

#### Q 数据库保护（访问）的内容有哪些？

利用权限机制；利用完整性约束防止法数据进入数据库；提供故障恢复能力，提供并发访问控制。



## 数据库设计

#### 1.数据库设计的步骤？

（1）需求分析： 分析用户的需求，包括数据、功能和性能需求；生成系统分析报告。
（2） 概念结构设计：主要采用E-R模型进行设计，包括画E-R图；生成全局E-R图
.（3）逻辑结构设计：通过将E-R图转换成表，实现从E-R模型到关系模型的转换，进行关系规范化；
（4） 数据库物理设计：主要是为所设计的数据库选择合适的存储结构和存储路径；
（5） 数据库的实施：包括编程、测试和试运行；
（6）数据库运行和维护：系统的运行和数据库的日常维护

#### 2.什么是数据库设计？

是指对于一个给定的应用环境，构造最优的数据库模式，建立数据库及其应用系统，使之能够有效地存储数据，满足各种用户的应用需求（信息要求和处理要求）。

#### 3.数据字典的内容及其作用？

数据字典通常包括数据项、数据结构、数据流、数据存储、处理过程5个部
	1.数据项：数据项描述 = {数据项名，数据项含义说明，别名，数据类型，取值范围……}
2.数据结构：数据结构反映了数据之间的组合关系。数据结构描述 = {数据结构名，含义说明，组成：{数据项或数据结构}}
3.数据流：数据流是数据结构在系统内传输的路径。数据流描述 = {数据流名，数据流来源，数据流去向，平均流量，高峰期流量，组成：{数据结构}}
4.数据存储：数据存储是数据结构停留或保存的地方。数据存储描述 = {数据存储名，说明，编号，输入的数据流，输出的数据流，组成：{数据结构}，数据量，存取频度，存取方式}
5.处理过程：处理过程的具体处理逻辑一般用判定表或判定树来描述。处理过程描述 = {处理过程名，说明，输入：{数据流}，输出：{数据流}，处理：{简要说明}}概念结构设计
需求分析阶段完成数据字典（用于表示收集到的数据）和一组数据流程图（Data Flow Diagram，DFD）

#### 4.设计概念结构通常有四类方法

自顶向下：即首先定义全局概念结构的框架，然后逐步细化
自底向上：即首先定义各局部应用的概念结构，然后将它们集成起来，得到全局概念结构
逐步扩张：首先定义最重要的核心概念结构，然后向外扩充
混合策略：即将自顶向下和自底向上相结合，用自顶向下策略设计一个全局概念结构的框架，以它为骨架集成由自底向上策略中设计的各局部概念结构。

#### 5.逻辑设计阶段主要的内容和步骤

1. 将E-R图转化为关系数据模型；
2. 关系模式规范化；
3. 关系模式优化。

#### 6.E-R模式合并时发生的三种冲突

1、属性冲突：
属性域冲突：属性值的类型、取值范围不一致。例如学生的学号是用整数还是用字符型表示？
属性取值单位冲突。
2、命名冲突：
同名异义:不同意义的对象在不同的局部采用了相同的名字。
异义同名：通一意义的对象在不同的局部应用中具有不同的名字。
1和2中的冲突靠协商解决。
3、结构冲突：
统一对象在不同的局部有不同的身份。
①一个对象在某个局部作为实体，而在另一个局部成了属性。解决办法，将实体转化为属性或者将属性转化为实体，使同一对象有相同的身份。
②容易对象在不同的局部应用中对应的实体属性组成不完全相同。解决办法，对实体的属性取在不同局部中的并集。
③实体之间的联系在不同的局部应用中具有不同的类型。如在一个局部中是一对一联系，在另一个中是多对多联系。解决办法，根据应用的语义对实体联系的类型进行综合或调整。

#### 7.物理设计的内容和步骤

1、确定数据库的物理结构
2、对所设计的物理结构进行评价

#### 8.数据库的运行与维护，从以下几个角度考虑：

1.数据库的转储和恢复
2.数据库的安全性、完整性控制
3.数据库性能的监督、分析和改造
4.数据库的重组织和重构造

## 完整性和安全性

#### 1.什么是数据库的完整性？什么是数据库的安全性？

数据库的完整性是指数据库中的数据的正确性、一致性和相容性。数据库的安全性是指保护数据库，防止因用户非法使用数据库造成数据泄露、更改或破坏。数据的完整性和安全性是一个问题的两个方面，都是为了保护数据库中的数据。前者旨在保护数据库中的数据，防止合法用户对数据库进行修改时破坏数据的一致性；而后者旨在保护数据库，防止未经授权的访问和恶意破坏和修改。

#### 2.为了维护数据库的完整性，DBMS应提供哪些支持？

(1)说明和定义完整性约束条件的方法：DBMS的DDL允许用户根据实际问题的语义说明和定义各种完整性约束条件。
(2)完整性检查机制：DBMS在数据更新可能破坏完整性时自动进行完整性检查。检查可以在更新操作执行时立即执行，也可以在事务提交时进行。
(3)违约处理：当数据更新违反完整性约束时，DBMS应当采取相应的措施，确保数据的完整性。

#### 3.实体完整性的定义与违约处理？

实体完整性在CREATE TABLE中用PRIMARY KEY定义。一种是定义为列级约束条件，另一种是定义为表级约束条件。
当用户程序对基本表插入一条记录或对主码列进行更新操作时，会进行如下检查
（1）检查主码值是否唯一，如果不唯一则拒绝插入或修改
（2）检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改

#### 4.参照完整性的定义与违约处理？

关系模型的参照完整性在CREATE TABLE中用FOREIGN KEY短语定义哪些列为外码，用REFERENCES短语指明这些外码参照哪些表的主码。

当不一致发生时，系统可以采用如下策略处理：
（1）拒绝(NO ACTION)执行：不允许该操作执行，该策略一般设置为默认策略
（2）级联(CASCADE)操作：当删除或修改被参照表的一个元组导致与参照表（SC）的不一致时，删除或修改参照表中的所有导致不一致的元组。
（3）设置为空值：当删除或修改被参照表的一个元组时造成了不一致，则将参照表中所有造成不一致的元组的对应属性设置为空值。
（4）置缺省值：进行更新，且对更新导致违反参照完整性的参照关系元组的外码置空值；其中缺省值必须是被参照关系某元组主码上的值。

#### 5.用户自定义完整性相关？

属性约束
关系约束
断言 断言是一种命名约束，表达了数据库状态必须满足的逻辑条件
域约束 在原理上类似于编程语言中变量的类型，就像不同变量可以有相同的数据类型，不同的属性可以有相同的域，声明一个域包括：域值类型，缺省值，域值的格式，对取值范围或取值集合的约束，不同域上的值不能比较

#### Q [触发器](https://so.csdn.net/so/search?q=触发器&spm=1001.2101.3001.7020)的作用？

触发器是一中特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。

#### Q 触发器的作用，什么时候用触发器,创建触发器的步骤？

（1）触发器的作用：
触发器是一种程序模块，是数据库的一种自动处理机制。触发器主要作用是保证数据库的安全性，例如：触发器通常通过对操作的记录来对数据库进行操作的审计，或实现复杂的约束条件
（2）什么时候用触发器：
根据触发器的触发条件可以分为3种触发器：分别为dml触发器、instead of触发器、ddl触发器。触发器的调用方式不同于存储过程和函数，它是通过“事件”来激活的。所谓事件，就是数据库的动作或用户的操作。触发器不能由用户显示调用，而是只有当触发事件发生并被捕捉到时，才会被触发。（事件-条件-动作模型）
（3）创建触发器的步骤：
创建触发器首先需要create trigger权限
触发器有3中类型：dml触发器、instead of触发器、ddl触发器。在创建语句上大致可以分为4步：
1、定义触发器
2、触发条件（区分触发器的类型）
3、声明部分
4、主体部分

#### 7.实现数据库安全性控制的常用方法和技术？

（1）用户标识和鉴别：
该方法由系统提供一定的方式让用户标识自己的名字或身份。每次用户要求进入系统时，由系统进行核对，通过鉴定后才能提供系统的使用权
(2)存取控制
通过用户权限定义和合法权检查确保只有合法权限的用户访问数据库，所有未授权的人员无法存取数据
(3)视图机制
为不同的用户定义视图，通过视图机制把要保密的数据对无权存取的用户隐藏起来，从而自动地对数据提供一定程度的安全保护。
(4)审计
建立审计日志，把用户对数据库的所有操作自动记录下来放入审计日志中，DBA可以利用审计跟踪的信息，重现导致数据库现有状况的一系列事件，找出非法存取数据的人，时间和内容等。
(5)数据加密
对存储和传输的数据进行加密处理，从而使得不知道解密算法的人无法获知数据的内容。
